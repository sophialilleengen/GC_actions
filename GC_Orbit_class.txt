import numpy as np
from scipy import interpolate
from scipy import integrate as intg
from scipy import optimize as opt


class GCorbit:
	def __init__(self,R,rho,bhmass): #filename of object containing interpolation of density profile
		self.r=R
		self.rho=rho
		self.s=interpolate.InterpolatedUnivariateSpline(np.log(self.r[:]),np.log(self.rho[:]))
		pot_y=self.potential(r,density,low=0.003,high=104.64,x_i=None,w_i=None,full_integration=True)
		self.pot=interpolate.InterpolatedUnivariateSpline(self.r,pot_y)

	def potential(r,density,low=0.003,high=104.64,x_i=None,w_i=None,full_integration=False):
		if True:
				sum1=np.zeros(n)
   				sum2=np.zeros(n)
				if isinstance(r,np.ndarray):
        				return np.array([potential(rr,density,low=low,high=high,x_i=x_i,w_i=w_i) for rr in r])
    				else:
        				if r<low or r>high:
            					sys.exit("r is smaller or bigger than star boundaries")
        				x1=((r-low)/2)*x_i+(r+low)/2
        				x2=((high-r)/2)*x_i+(high+r)/2
        				for i in range(n):
            					s1=density(x1[i])
            					s2=density(x2[i])
            					sum1[i]=(w_i[i]*x1[i]**2*s1)
            					sum2[i]=(w_i[i]*x2[i]*s2)
        				sum_1=np.sum(sum1)
        				sum_2=np.sum(sum2)
        				return -4*np.pi*G*((r-low)/(2*r)*sum_1+(high-r)/2*sum_2)
		else:
			return self.pot(r,density,low=0.003,high=104.64,x_i=None,w_i=None)
    
	def potential_bh(r,bhmass):
		return -G*bhmass/r

#addiere sternen- und bh-potential vor interpolation?

	def r_derivative(potential):
		return potential.derivative

	def force(x,y,z,potential):
		force=np.array(3)
		r=np.sqrt(x**2+y**2+z**2)
		drdx=x/r
		drdy=y/r
		drdz=z/r
		force[0]=r_derivative(potential)*drdx
		force[1]=r_derivative(potential)*drdy
		force[2]=r_derivative(potential)*drdz
		return force
		

	def orbit(x0,y0,z0,vx0,vy0,vz0,N): #noch von force abhängig machen?
		xl=np.zeros(N+1)
		yl=np.zeros(N+1)
		zl=np.zeros(N+1)

		x_l=np.sqrt(xl**2+yl**2+zl**2)

		vxl=np.zeros(N+1)
		vyl=np.zeros(N+1)
		vzl=np.zeros(N+1)

		xl[0]=x0
		yl[0]=y0
		zl[0]=z0

		vxl[0]=vx0
		vyl[0]=vy0
		vzl[0]=vz0

		for i in range(N):
		    	xl[0]=x0
    			yl[0]=y0
			zl[0]=z0
    
    			a=force(xl[i],yl[i],zl[i]) #hier auch noch potential rein?
    
    			xl[i+1]=xl[i]+vxl[i]*dt+1./2.*a[0]*dt**2
    			yl[i+1]=yl[i]+vyl[i]*dt+1./2.*a[1]*dt**2
    			zl[i+1]=zl[i]+vzl[i]*dt+1./2.*a[2]*dt**2
    
    			a_1=force(xl[i+1],yl[i+1],zl[i+1]) #und hier auch potential?
    
    			vxl[i+1]=vxl[i]+1./2.*(a[0]+a_1[0])*dt
    			vyl[i+1]=vyl[i]+1./2.*(a[1]+a_1[1])*dt
   			vzl[i+1]=vzl[i]+1./2.*(a[2]+a_1[2])*dt


	def actions(xl,yl,zl,vxl,vyl,vzl): #hier auch potential in die klammer?
		actions=np.array(3)

		rl=np.sqrt(xl**2+yl**2+zl**2)

		#angular moments without mass
		Lx=yl*vzl-zl*vyl
		Ly=zl*vxl-xl*vzl
		Lz=xl*vyl-yl*vxl

		L=np.sqrt(Lx**2+Ly**2+Lz**2)

		phipot=potential(rl)

		E=vxl**2./2.+vyl**2./2.+vzl**2./2.+phipot

		def periapocenter(r):
    			pot=potential(r)
    			return (1/r)**2.+2.*(pot-E[0])/L[0]**2.

		rmin=opt.fsolve(periapocenter,np.min(rl)) #nicht min(rl) sondern einfach kleienr wert weil ich es erst durch orbit integration weiss
		rmax=opt.fsolve(periapocenter,np.max(rl))

		def jrint(r,E,L):
		    	pot=potential(r)
		    	return np.sqrt(2.*E-2.*pot-L**2./r**2.)

		J_phi=Lz
		J_theta=L-np.abs(Lz)

		J_r=np.zeros(len(J_phi))
		for i in range(len(J_r)):
    			J_r[i]=1/np.pi*intg.quad(jrint,rmin,rmax)[0]

		#J_ri=cs.G*mges/np.sqrt(-2.*E)-1./2.*(L+np.sqrt(L**2.-4.*cs.G*mges*b))
		
		
		actions[0]=J_phi
		actions[1]=J_theta
		actions[2]=J_r

		return actions

	def angularmom(xl,yl,zl,vxl,vyl,vzl):
    		Lx=yl*vzl-zl*vyl
    		Ly=zl*vxl-xl*vzl
    		Lz=xl*vyl-yl*vxl
    		L=np.sqrt(Lx**2+Ly**2+Lz**2)
    		return L,Lx,Ly,Lz


	def energy(xl,yl,zl,vxl,vyl,vzl):
    		pot=potential(xl,yl,zl,M=mges,b=b)
    		E=vxl**2./2.+vyl**2./2.+vzl**2./2.+pot
    		return E

	def periapocenter(rl):
	#    r=np.sqrt(xl**2+yl**2+zl**2)
    		pot=potential(xl,yl,zl,M=mges,b=b)
    		return (1/rl)**2.+2.*(pot-E[0])/L[0]**2.
	
	rl=np.sqrt(xl**2+yl**2+zl**2)

	rmin=opt.fsolve(periapocenter,np.min(rl)) #nicht min(rl) sondern einfach kleiner wert weil ich es erst durch orbit integration weiss
	rmax=opt.fsolve(periapocenter,np.max(rl))

	def j_rint(xl,yl,zl,vxl,vyl,vzl,E,L,pot):
    		r=np.sqrt(xl**2+yl**2+zl**2)
    		pot=potential(xl,yl,tl,M=M,b=b)
    		E=energy(vxl,vyl,vzl,pot)
    		L=angularmom(xl,yl,zl,vxl,vyl,vzl)
    		return np.sqrt(2.*E-2.*pot-L**2./r**2.)

	def J_phi(xl,yl,vxl,vyl):
    		Lz=xl*vyl-yl*vxl
    		J_phi=Lz
    		return J_phi
    
	def J_theta(L,Lz):
    		L=angularmom(xl,yl,zl,vxl,vyl,vzl)[0]
    		Lz=angularmom(xl,yl,zl,vxl,vyl,vzl)[1]
    		J_theta=L-np.abs(Lz)
    		return J_theta
	
	#j_rint=lambda r_var: np.sqrt(2.*E-2.*Phi(r_var)-L**2./r_var**2.)

	def J_r():
	#    J_r=np.zeros(len(J_phi))
	#for i in range(len(J_r)):
    		J_r=1/np.pi*intg.quad(j_rint,rmin,rmax)[0] #rmin,rmax,args=(E,L)
	#J_ri=cs.G*mges/np.sqrt(-2.*E)-1./2.*(L+np.sqrt(L**2.-4.*cs.G*mges*b))
    		return J_r
		